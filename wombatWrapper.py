"""
Module to launch the wombat GUI 

This script is called directly via the command line and uses a set of passed
parameters to sort out which of the three modes is being used for launch and
proceeds accordingly. The three modes are:

1. Using a text file list of prepped files (as generated by wombatProcessObs.py)
2. Using a set of times and satellite tags to search for prepped files
3. Using a reload file

This wrapper is designed to work with the folder structure established by 
wombatPull/ProcessObs where everything is in wbFits in the same location as
where this script is executed and the different obs are sorted into sub folders
in the format satellite/instrument/additionalDetails. The wombatGUI does not 
care about the file structure, only the maps it is passed, so it is entirely
possible to create a different wrapper or modify this one for different setups

Usage:
    The most basic call is

        python3 wombatWrapper.py file

    where for options 1/3 the file is either the list of text files or the reload file

    To launch mode 2 use
    
         python3 wombatWrapper.py time1 time2 inst1... instN EXTRA1 EXTRA2 EXTRA3

    where time1/2 are the start/end time formated anyway accepted by Sunpy parse_time
    and inst1->instN are N instrument tags, selecting from the options below with no
    requirements on capital/lowercase letters. You can also pass up to five extra keywords
    (represented by the  EXTRA) but these are not required. The  options are the difference
    mode (either RD or BD), T#,  the time resolution in minutes to use for pulling (processed)
    observations, n#, the number of wireframes, diffEUV to flag to take EUV differences, and
    ovw to include the overview panel.


        
    Available inst tags:
            AIAnum  = SDO AIA where num represents a wavelength from [94, 131, 171*, 
                      193*, 211, 304*, 335, 1600, 1700] with * most common
            C2      = LASCO C2
            C3      = LASCO C3
            COR1    = STEREO COR1
            COR2    = STEREO COR2    
            EUVInum = STEREO EUVI where num is a wavelength from [171, 195, 284, 304]
            HI1     = STEREO HI1
            HI2     = STEREO H2
            SoloHI  = All quadrants from Solar Orbiter HI
            SoloHI1 = Quadrant 1 from Solar Orbiter HI
            SoloHI2 = Quadrant 2 from Solar Orbiter HI
            SoloHI3 = Quadrant 3 from Solar Orbiter HI
            SoloHI4 = Quadrant 4 from Solar Orbiter HI
            WISPR   = Both inner and outer from PSP WISPR
            WISPRI  = Inner only from PSP WISPR
            WISRPO  = Outer only from PSP WISPR
            * all STEREO values will both pull A and B (as available) if written as 
              above but one can add the A/B tag on the end (e.g. COR2A) to select a
              single STEREO

Outputs:
    No outputs unless the save button is clicked. If clicked, it will save fits files
    for the backgrounds (processed as RD/BD) in wbFits/reloads and in wboutputs it
    will save wombatSummaryFile.txt which can be used to reload the current setup and
    a png file for each observation panel and one for the overview panel (if present)

External Calls:
    releaseTheWombat from wombatGUI
    setupTimeStuff from wombatProcessObs


"""

from astropy.io import fits
import astropy.units as u
import numpy as np
import sunpy.map
from sunpy.time import parse_time
import sys, os
import pickle
import sunpy


sys.path.append('wombatCode/') 
from wombatGUI import releaseTheWombat
from wombatProcessObs import setupTimeStuff

# |--------------------------------|
# |------- Suppress Warnings ------|
# |--------------------------------|
# Astropy/sunpy have a lot of thoughts about missing
# keywords so set the logger to only complain about
# actual errors not all warnings
import logging
logging.basicConfig(level='INFO')
slogger = logging.getLogger('sunpy')
slogger.setLevel(logging.ERROR)
alogger = logging.getLogger('astropy')
alogger.setLevel(logging.ERROR)

# |--------------------------------|
# |------ Avail Instruments  ------|
# |--------------------------------|
# Master array of all allowed instrument tags
allowedInsts = ['AIA94', 'AIA131', 'AIA171','AIA193','AIA211','AIA304','AIA335','AIA1600','AIA1700', 'C2', 'C3', 'COR1', 'COR2', 'EUVI171', 'EUVI195', 'EUVI284', 'EUVI304', 'HI1', 'HI2', 'COR1A', 'COR2A', 'EUVI171A', 'EUVI195A', 'EUVI284A', 'EUVI304A', 'HI1A', 'HI2A', 'COR1B', 'COR2B', 'EUVI171B', 'EUVI195B', 'EUVI284B', 'EUVI304B', 'HI1B', 'HI2B', 'SOLOHI', 'SOLOHI1', 'SOLOHI2', 'SOLOHI3', 'SOLOHI4', 'WISPR', 'WISPRI', 'WISPRO']


# |------------------------------------------------------------|
# |------------------- Process Reload File --------------------|
# |------------------------------------------------------------|
def processReload(fileIn, reloadFold='wbfits/reloads/'):
    """
    Function to process a reload file
    
    This will take a file with two columns corresponding to keywords and values and
    process them into the inputs for the wombat gui. It will get the array of 
    background images to show and initial values for the wireframe/obs parameters

    Inputs:
        fileIn: a text file with two columns (keyword value)
    
    Optional Inputs:
        reloadFold: the path to the folder where the reload fits files are saved
                    defaults to wbfits/reloads/
           
    Outputs:
        allFH: an array in the form [inst1, inst2, ...] where each insts is an array
              of [[maps], [hdrs]] where maps and hdrs are time series of the obs 
              maps and their corresponding headers 
             (e.g. [[[COR2Amap1, COR2Amap2, ...], [COR2Ahdr1, COR2Ahdr2, ...]],
                    [[C2map1, C2map2, ...], [C2Ahdr1, C2hdr2, ...]],
                    [[AIA171map1, AIA171map2, ...], [AIA171hdr1, AIA171hdr2, ...]]])
    
        reloadDict: a dictionary of keywords and values that wombatGUI will use to set slider
                    values for both the wireframes and the background scaling
    
    """
    # |-----------------------------------------------|
    # |------ Load everything into a Dictionary ------|
    # |-----------------------------------------------|
    if os.path.exists(fileIn):
        print ('Loading configuration from '+fileIn)
        data = np.genfromtxt(fileIn,dtype=str)
        # Get the number of wfs and sats while making Dict
        nWFs, nSats = 0, 0
        reloadDict = {}
        for i in range(len(data[:,0])):
            mykey = data[i,0]
            # Add a wireframe
            if 'WFtype' in mykey: nWFs += 1
            # Add an obs panel
            if 'ObsType' in mykey: nSats += 1
            # Will have multiple ObsTimes for each panel
            # Collect into a single array
            if 'ObsFile' in mykey:
                thisKey = str(mykey).replace(':','')
                if thisKey not in reloadDict:
                    reloadDict[thisKey] = [data[i,1]]
                else:
                    reloadDict[thisKey].append(data[i,1])
            else:
                reloadDict[str(mykey).replace(':','')] = str(data[i,1]).replace('Half', 'Half ')
        reloadDict['nWFs'] = nWFs
        reloadDict['nSats'] = nSats

        # |-----------------------------------------------|
        # |-------- Process the observation files --------|
        # |-----------------------------------------------|       
        allTypes = []
        allTimes = []
        for i in range(nSats):
            # Build the reload file name from ObsType/ObsTime
            # wombat will save in a systematic manner of 
            # wombat_YYYY-MM-DDTHHMMSS_Sat_Inst.fits
            allTypes.append(np.array(reloadDict['ObsType'+str(i+1)]))
            allTimes.append(np.array(reloadDict['ObsFile'+str(i+1)]))
            
        allFH = fits2maps(allTimes, allTypes)    
        
        return allFH, reloadDict
        
    else:
        sys.exit('Reload file not found by processReload, cannot launch')

# |------------------------------------------------------------|
# |--------------- Convert fits files to maps -----------------|
# |------------------------------------------------------------|
def fits2maps(filesIn, names, diffEUV=False):
    """
    
    ***** Replaced this with arr2maps in wombayProcessObs *****
    
    
    Function to convert a list of fits files into an array of maps and headers
    
    This will take an array of file names, open them up and convert them to
    maps. It then will determine a base or running difference. The output can
    be passed directly to wombatGUI for the background images

    Inputs:
        fileIn: an array of a time series array of fits file names for each sat/inst
                e.g. [[COR2Afits1, COR2Afits1, ...],
                      [C2fits1, C2fits2, ...],
                      [AIA171fits1, AIA171fits2, ...]]
                There is no requirement for the same number of times in each list
    
        names: a tag for each sat/inst. This is less restrictive than most wombat tag
               requirements, it currently just looks for EUVI or AIA to flag those cases
    
    Optional Inputs:
        diffEUV: whether or not to difference EUV images (True/False)
                 defaults for False
           
    Outputs:
        allFH: an array in the form [inst1, inst2, ...] where each insts is an array
              of [[maps], [hdrs]] where maps and hdrs are time series of the obs 
              maps and their corresponding headers 
             (e.g. [[[COR2Amap1, COR2Amap2, ...], [COR2Ahdr1, COR2Ahdr2, ...]],
                    [[C2map1, C2map2, ...], [C2Ahdr1, C2hdr2, ...]],
                    [[AIA171map1, AIA171map2, ...], [AIA171hdr1, AIA171hdr2, ...]]])
     
    """
    # |-----------------------------------------------|
    # |----------- Open up the fits files ------------|
    # |-----------------------------------------------|
    allFH0 = [[[], []] for i in range(len(names))]
    for i in range(len(names)):
        for aF in filesIn[i]:
            with fits.open(aF) as hdulist:
                im  = hdulist[0].data
                hdr = hdulist[0].header
                hdr['myFits'] = aF
            allFH0[i][0].append(im)
            allFH0[i][1].append(hdr)
            
    # |-----------------------------------------------|
    # |---------- Convert/Difference files -----------|
    # |-----------------------------------------------|
    allFH = []
    for i in range(len(allFH0)):
        # Can do single file if not doing a difference
        # Otherwise need to make sure more than one file
        if (len(allFH0[i][0]) > 1) or (('EUVI' in names[i]) & (not diffEUV)) or (('AIA' in names[i]) & (not diffEUV)):
            # Create a holder for this inst in the output 
            allFH.append([[], [], []])
            
            # Is EUVI and haven't flagged diffEUV so just pass along
            if (('EUVI' in names[i]) & (not diffEUV)) or (('AIA' in names[i]) & (not diffEUV)):            
                for j in range(len(allFH0[i][0])):
                    myData = allFH0[i][0][j]
                    myHdr  = allFH0[i][1][j]
                    myMap  = sunpy.map.Map(myData, myHdr)
                    allFH[i][0].append(myMap)
                    allFH[i][1].append(myMap)
                    allFH[i][2].append(myHdr)
            
            # Process any form of difference
            else:
                for j in range(len(allFH0[i][0])-1):
                    # Get the data for a time step
                    myData = allFH0[i][0][j+1]
                    myHdr  = allFH0[i][1][j+1]
                    
                    # Get the bases
                    runBase  = allFH0[i][0][j]
                    runFile  = filesIn[i][j]
                    baseBase = allFH0[i][0][0]
                    baseFile = filesIn[i][0]
                    
                    # Make sure files are same shape and diff    
                    if (myData.shape == runBase.shape) & (myData.shape == baseBase.shape):
                        # Run diff
                        diffData = myData - runBase
                        myHdr['diffFile'] = runFile
                        diffMap = sunpy.map.Map(diffData, myHdr)
                        allFH[i][0].append(diffMap)
                        # Base diff
                        diffData = myData - baseBase
                        myHdr['diffFile'] = baseFile
                        diffMap = sunpy.map.Map(diffData, myHdr)
                        allFH[i][1].append(diffMap)
                        # Add hdr
                        allFH[i][2].append(myHdr)

                    else:
                        print('Size mismatch for ' +names[i] + allFH0[i][1][j+1]['DATE-OBS'])

        elif len(allFH0[i][0]) == 0:
            print ('No files found for ' +  names[i] )
                        
        # Return if trying to make a difference from a single file    
        else:
            print ('Cannot make diff for '+ names[i]+ ' from only a single file')
        
        # Make sure we have some files, exit if none
        tots = 0
        for item in allFH:
            tots += len(item[0])
        if tots == 0:
            sys.exit('No observations found for any instrument, exiting...')
    
    return allFH

# |------------------------------------------------------------|
# |----------------- Pull Processed From List -----------------|
# |------------------------------------------------------------|
def pullProcFiles(theFile, diffEUV=False):
    """
    Function to process a sat list file
    
    This will take a file with a single columns and run through line by line
    checking if it is a satellite/inst name tag or a fits files. It must start 
    with a name and will add all the following fits files to an array for that
    tag until it hits the next tag. The files should be processed as done in
    wombatProcessObs but are not differenced. The list is then passed to fits2maps

    Inputs:
        fileIn: a text file with a single column with either a sat/inst name
                or the corresponding processed fits files to use
    
    
    Optional Inputs:
        diffEUV: whether or not to difference EUV images (True/False)
                 defaults for False
           
    Outputs:
        allFH: an array in the form [inst1, inst2, ...] where each insts is an array
              of [[maps], [hdrs]] where maps and hdrs are time series of the obs 
              maps and their corresponding headers 
             (e.g. [[[COR2Amap1, COR2Amap2, ...], [COR2Ahdr1, COR2Ahdr2, ...]]
                    [[C2map1, C2map2, ...], [C2Ahdr1, C2hdr2, ...]]
                    [[AIA171map1, AIA171map2, ...], [AIA171hdr1, AIA171hdr2, ...]]])
     
    """
    
    # |-------------------------------------|
    # |---------- Set up holders -----------|
    # |-------------------------------------|
    allFH0 = []
    names = []
    counter = -1
    
    # |-------------------------------------|
    # |----------- Process File ------------|
    # |-------------------------------------|
    pFiles = np.genfromtxt(theFile, dtype=str)
        
    for aF in pFiles:
        if '.fits' not in aF:
            print ('Reading in ', aF, ' files')
            allFH0.append([])
            names.append(aF)
            counter += 1
        else:
            print(' ', aF)
            allFH0[counter].append(aF)
    
    # |-------------------------------------|
    # |------------ Pass along -------------|
    # |-------------------------------------|
    allFH = fits2maps(allFH0, names, diffEUV=diffEUV)
    
    return allFH

# |------------------------------------------------------------|
# |----------------- Look for Matching Files ------------------|
# |------------------------------------------------------------|
def findFiles(timesIn, insts, nMax=20, obsFold='wbFits/', diffEUV=False, tRes=None):
    """
    Function to look for processed files in a given time range for specifc insts
    
    This searches a folder for fits files that have already been processed by 
    wombatProcessObs. It assumes everything is sorted into sat/insts folders
    in the default wombat manner and will likely fail with anything different.
    After finding the files it sends the list to fits2map for processing

    Inputs:
        timesIn: an array with [startTime, endTime] in any string format accepted by 
                 parse_time (from sunpy)
    
        insts:   an array of instrument tags to search for matching data. The tags 
                 must be selected from the options below
    
                 Available inst tags:
                        AIAnum  = SDO AIA where num represents a wavelength from [94, 131, 171*, 
                                  193*, 211, 304*, 335, 1600, 1700] with * most common
                        C2      = LASCO C2
                        C3      = LASCO C3
                        COR1    = STEREO COR1
                        COR2    = STEREO COR2    
                        EUVInum = STEREO EUVI where num is a wavelength from [171, 195, 284, 304]
                        HI1     = STEREO HI1
                        HI2     = STEREO H2
                        SoloHI  = All quadrants from Solar Orbiter HI
                        SoloHI1 = Quadrant 1 from Solar Orbiter HI
                        SoloHI2 = Quadrant 2 from Solar Orbiter HI
                        SoloHI3 = Quadrant 3 from Solar Orbiter HI
                        SoloHI4 = Quadrant 4 from Solar Orbiter HI
                        WISPR   = Both inner and outer from PSP WISPR
                        WISPRI  = Inner only from PSP WISPR
                        WISRPO  = Outer only from PSP WISPR
                        * all STEREO values will both pull A and B (as available) if written as 
                          above but one can add the A/B tag on the end (e.g. COR2A) to select a
                          single STEREO
    
    
    Optional Inputs:
        nMax:     the maximum number of files to pull for each instrument. this is 
                  ignored when tRes is set
                  defaults to 20
    
        obsFold:  the top folder where the processed files are stored (in subfolders)
                  defaults to wbFits/
            
        diffEUV:  whether or not to difference EUV images (True/False)
                  defaults for False
    
        tRes:     the time resolution (in minutes) to pull data
                  defaults to None so that nMax is used instead
           
    Outputs:
        allFH: an array in the form [inst1, inst2, ...] where each insts is an array
              of [[maps], [hdrs]] where maps and hdrs are time series of the obs 
              maps and their corresponding headers 
             (e.g. [[[COR2Amap1, COR2Amap2, ...], [COR2Ahdr1, COR2Ahdr2, ...]]
                    [[C2map1, C2map2, ...], [C2Ahdr1, C2hdr2, ...]]
                    [[AIA171map1, AIA171map2, ...], [AIA171hdr1, AIA171hdr2, ...]]])
     
    """
    
    # |-----------------------------------------------|
    # |---------- Grab date/time variables -----------|
    # |-----------------------------------------------|
    # ymds is list of strs in format yyyymmdd for each day in range
    # hms is hhmm for start time and stop time
    ymds, hms = setupTimeStuff(timesIn)
    hm0 = hms[0]
    hmf = hms[1]
    nDays = len(ymds)
    
    # |-----------------------------------------------|
    # |---------- Set up the inst folders ------------|
    # |-----------------------------------------------|
    toGrab = []   
    names  = [] 
    for inst in insts:
        inst = inst.upper()
        # Check if it is a valid instrument key
        if inst not in allowedInsts:
            sys.exit(inst+' not a valid instrument tag, exiting from findFiles.')
            
        # If so, add the path to the list we will pull from
        else:
            # PSP Instruments
            if inst == 'WISPRI':
                toGrab.append(obsFold+'PSP/WISPR/Inner/')
                names.append(inst)
            elif inst == 'WISPRO':
                toGrab.append(obsFold+'PSP/WISPR/Outer/')
                names.append(inst)
            elif inst == 'WISPR':
                toGrab.append(obsFold+'PSP/WISPR/Inner/')
                toGrab.append(obsFold+'PSP/WISPR/Outer/')
                names.append('WISPRI')
                names.append('WISPRO')
            
            # SDO Instruments
            elif 'AIA' in inst:
                toGrab.append(obsFold+'SDO/AIA/'+inst.replace('AIA','')+'/')
                names.append(inst)
            
            # SOHO Instruments
            # 'C2', 'C3'
            elif inst in ['C2', 'C3']:
                toGrab.append(obsFold+'SOHO/LASCO/'+inst+'/')
                names.append(inst)
            
            # SolO Instruments
            elif inst in ['SOLOHI1', 'SOLOHI2', 'SOLOHI3', 'SOLOHI4']:
                toGrab.append(obsFold+'SolO/SoloHI/'+inst.replace('SOLOHI','')+'/')
                names.append(inst)
            elif inst == 'SOLOHI':
                toGrab.append(obsFold+'SolO/SoloHI/Mosaic/')
                names.append(inst)
            
            # STEREO Instruments
            #  'COR1', 'COR2', 'EUVI171', 'EUVI195', 'EUVI284', 'EUVI304', 'HI1', 'HI2', 
            elif ('COR' in inst) or ('HI' in inst):
                if inst[-1] in ['A','B']:
                    toGrab.append(obsFold+'STEREO/'+inst+'/')
                    names.append(inst)
                else:
                    toGrab.append(obsFold+'STEREO/'+inst+'A/')
                    names.append(inst+'A/')
                    if str(timesIn[0]) < '2014-10-01T00:00:00.000':
                        toGrab.append(obsFold+'STEREO/'+inst+'B/')
                        names.append(inst+'B/')
            elif 'EUVI' in inst:
                if inst[-1] in ['A','B']:
                    myEUVI = 'EUVI'+inst[-1]
                    myWav  = inst.replace('EUVI','')[:-1]
                    toGrab.append(obsFold+'STEREO/'+myEUVI+'/'+myWav+'/')
                    names.append(inst)
                else:
                    toGrab.append(obsFold+'STEREO/EUVIA/'+inst.replace('EUVI','')+'/')
                    names.append(inst+'A/')
                    if str(timesIn[0]) < '2014-10-01T00:00:00.000':
                        toGrab.append(obsFold+'STEREO/EUVIB/'+inst.replace('EUVI','')+'/')
                        names.append(inst+'B/')
    
    # |-----------------------------------------------|
    # |---------- Search the inst folders ------------|
    # |-----------------------------------------------|
    # Search in the folders for files matching the desired date/time
    grabFiles = []                    
    for aFold in toGrab:
        myGrab = []
        allFiles = os.listdir(aFold)
        for aF in allFiles:
            # search all days
            for j in range(nDays):
                # check if date string in filename
                if (ymds[j] in aF):
                    hm = aF[-11:-7]
                    addIt = True
                    # if date matches, check time on first/last date
                    if (j == 0) & (hm < hms[0]):
                        addIt = False
                    elif (j == nDays-1) & (hm > hms[1]):
                        addIt = False
                    # Add it to the list to grab if it matches    
                    if addIt:
                        myGrab.append(aFold+aF)
        grabFiles.append(np.sort(np.array(myGrab)))
    
    # |-----------------------------------------------|
    # |------- Downselect by Time Resolution ---------|
    # |-----------------------------------------------|
    if type(tRes) != type(None):
        tDelta = tRes * u.minute
        for i in range(len(grabFiles)):
            toKeep = []
            for j in range(len(grabFiles[i])):
                aF = grabFiles[i][j]
                myT = parse_time(aF[-20:-7])
                if j == 0:
                    toKeep.append(aF)
                    lastT = myT
                else:
                    myDiff = (myT - lastT).to(u.minute)
                    if myDiff > tDelta:
                        toKeep.append(aF)
                        lastT = myT
            grabFiles[i] = toKeep
        
    # |-----------------------------------------------|
    # |------- Downselect by Max Number Files --------|
    # |-----------------------------------------------|
    # This is a quick filtering, the actual output number is
    # of order nMax, not exactly nMax
    if type(tRes) != type(None):
        for i in range(len(grabFiles)):
            if len(grabFiles[i]) > nMax:
                downSel = int(len(grabFiles[i])/nMax)    
                grabFiles[i] = grabFiles[i][::downSel]

    # Send to fits2maps                      
    allFH = fits2maps(grabFiles, names, diffEUV=diffEUV)
    
    return allFH

# |------------------------------------------------------------|
# |----------------------- Main Wrapper -----------------------|
# |------------------------------------------------------------|
def runWombatOLD(args):
    """
    Main wrapper to run the wombat gui from a list of arguments, either from an external
    program or by calling wombatPullObs.py at the command line
    
    This accepts a list of arguments and automatically determines how to run
    wombat using one of three methods. The three possible modes are:

    1. Using a text file list of prepped files (as generated by wombatProcessObs.py)
    2. Using a set of times and satellite tags to search for prepped files
    3. Using a reload file 

    Inputs:
        args: an list of arguments, either sys.argv passed from calling this file directly
              or whatever is passed by an external call to runWombat. The code checks if
              the first value has '.py' in it (as from sys.argv) and tosses it out if so.
              If a single value is passed then it needs to be a text file with either the
              list of prepped files or a reload file. Alternative, two time strings and a 
              set of instrument tags can be passed.
    
    Examples:
        The most basic call is

            runWombat([file])

        where for options 1/3 the file is either the list of text files or the reload file

        To launch mode 2 use
    
              runWombat([time1 time2 inst1... instN EXTRA1 EXTRA2 EXTRA3 EXTRA4 EXTRA5])

        where time1/2 are the start/end time formated anyway accepted by Sunpy parse_time
        and inst1->instN are N instrument tags, selecting from the options below with no
        requirements on capital/lowercase letters. You can also pass up to five extra keywords
        (represented by the  EXTRA) but these are not required. The  options are T#, the time 
        resolution in minutes to use for pulling (processed) observations, n#, the number of 
        wireframes, diffEUV to flag to take EUV differences, and ovw to include the overview panel.

        Available inst tags:
            AIAnum  = SDO AIA where num represents a wavelength from [94, 131, 171*, 
                        193*, 211, 304*, 335, 1600, 1700] with * most common
            C2      = LASCO C2
            C3      = LASCO C3
            COR1    = STEREO COR1
            COR2    = STEREO COR2    
            EUVInum = STEREO EUVI where num is a wavelength from [171, 195, 284, 304]
            HI1     = STEREO HI1
            HI2     = STEREO H2
            SoloHI  = All quadrants from Solar Orbiter HI
            SoloHI1 = Quadrant 1 from Solar Orbiter HI
            SoloHI2 = Quadrant 2 from Solar Orbiter HI
            SoloHI3 = Quadrant 3 from Solar Orbiter HI
            SoloHI4 = Quadrant 4 from Solar Orbiter HI
            WISPR   = Both inner and outer from PSP WISPR
            WISPRI  = Inner only from PSP WISPR
            WISRPO  = Outer only from PSP WISPR
            * all STEREO values will both pull A and B (as available) if written as 
              above but one can add the A/B tag on the end (e.g. COR2A) to select a
              single STEREO
    

           
    Outputs:
        No outputs unless the save button is clicked. If clicked, it will save fits files
        for the backgrounds (processed as RD/BD) in wbFits/reloads and in wboutputs it
        will save wombatSummaryFile.txt which can be used to reload the current setup and
        a png file for each observation panel and one for the overview panel (if present)
        
    """
    # |-----------------------------------------------|
    # |--------- Check for EXTRA variables -----------|
    # |-----------------------------------------------|
    # Check the last two entries of the call to see if passed info
    # about RD vs BD or if given an int to use for tRes in findFiles    
    if '.py' in args[0]:
        args = args[1:]
    diffMode = 'RD'
    tRes = None
    toRm = 0
    nWFs  = 1 
    diffEUV  = False
    overviewPlot = False
    
    if len(args) > 1:
        for i in [-1,-2, -3, -4, -5]:
            if len(args) > -i:
                val = args[i].upper()
                if val.upper() in ['BD', 'RD']:
                    diffMode = val
                    toRm += 1
                # Check if has a T but not long enough to be a datetime    
                elif ('T' in val) and (len(val) < 5):
                    tRes = int(val.replace('T',''))
                    toRm += 1
                elif 'N' in val:
                    nWFs = int(val.replace('N',''))
                    toRm += 1
                # be nice to those that forget an f
                elif val in ['DIFFEUV', 'DIFEUV']:
                    diffEUV = True
                    toRm += 1
                # Dunno why anyone would write more than ovw but allow it
                # ovw short and reminds CK of Al Snow
                elif val in ['OVW', 'OVERVIEW', 'OVERVIEWWINDOW']:
                    overviewPlot = True
                    toRm += 1
                
                
    if toRm > 0:
        args = args[:-toRm]
    
    # |-----------------------------------------------|
    # |------------ Check for a text file ------------|
    # |-----------------------------------------------|
    # Check if we were passed a file
    # Could be either a reload file or a list of pre processed obs
    if len(args) == 1:
        theFile = args[0]
    
        doReload = False
        preProc  = False
    
        # Check the go to names for reload/obsList
        if 'SummaryFile' in theFile:
            doReload = True
        elif 'obslist' in theFile:
            preProc = True
        # Otherwise open the file, check if one column or two
        # pass the opened file and flag as such
        else:
            openFile = np.genfromtxt(theFile, dtype=str)
            # If list of processed files then is single column
            # but len will pull the full string len
            if len(openFile[0]) > 2:
                preProc = True
            # If reload it should be two columns
            if len(openFile[0]) == 2:
                doReload = True

        # Process Reload    
        if doReload:    
            allFH, reloadDict = processReload(theFile)
        else:
            reloadDict = None
        
        # Process obsList
        if preProc:
            allFH = pullProcFiles(theFile, diffEUV=diffEUV)
    
    # |-----------------------------------------------|
    # |--------- Process times/instruments -----------|
    # |-----------------------------------------------|
    elif len(args) >= 3:
        reloadDict = None
        times = [args[0],args[1]]
        if times[1] < times[0]:
            sys.exit('Exiting WOMBAT, start time is after end time...')
        insts = []
        j = 2
        while j < len(args):
            insts.append(args[j])
            j += 1
        allFH = findFiles(times, insts, tRes=tRes, diffEUV=diffEUV)
        
    # Exit if haven't been passed anything
    else:
        sys.exit('Need to pass either a file or list of times+insts to wombatWrapper.py') 

    # |-----------------------------------------------|
    # |----------- Launch the WOMBAT GUI -------------|
    # |-----------------------------------------------|    
    releaseTheWombat(allFH, reloadDict=reloadDict, overviewPlot=overviewPlot, nWFs=nWFs)   

def runWombat(args):
    theFile = args[1]
    doReload     = False
    overviewPlot = False
    
    # Assume reload file not pickle if name includes SummaryFile
    if 'SummaryFile' in theFile:
        doReload = True
        sys.exit("Need to redo loading reload")
    # Assume its a pickle. Might want to add check 
    else:
        reloadDict = None
        # Open the pickle
        with open(theFile, 'rb') as file:
            bkgData = pickle.load(file)
        
    nWFs = 1
    if len(args) == 3:
        nWFs = int(args[2])
    elif len(args) > 3:
        sys.exit('Too many arguments given, syntax is python3 wombatWrapper.py file nWFs where file is a background pickle or reload file and nWFs is the number of wireframes')    
        
    releaseTheWombat(bkgData, reloadDict=reloadDict, overviewPlot=overviewPlot, nWFs=nWFs)   
        
        
if __name__ == '__main__':
    runWombat(sys.argv)
